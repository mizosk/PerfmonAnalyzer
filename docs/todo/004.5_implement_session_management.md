# タスク004.5: セッション管理機能の実装

**ステータス**: 未着手  
**優先度**: 高  
**見積もり**: 2時間

---

## 概要

CSVアップロード後にセッションIDを発行し、解析済みデータをメモリ上で管理する機能を実装する。これにより、AnalysisControllerが実際に動作するようになる。

## 前提条件

- タスク003（CSVインポータ）が完了していること
- タスク004（傾き分析機能）が完了していること

## 作業内容

### 1. SessionInfo モデル作成

`Models/SessionInfo.cs`:

```csharp
public class SessionInfo
{
    public string SessionId { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime LastAccessedAt { get; set; }
    public List<CounterInfo> Counters { get; set; }
}
```

### 2. IDataService インターフェース作成

`Services/IDataService.cs`:

```csharp
public interface IDataService
{
    /// <summary>
    /// 新しいセッションを作成し、カウンターデータを保存する
    /// </summary>
    string CreateSession(List<CounterInfo> counters);
    
    /// <summary>
    /// セッションIDからカウンターデータを取得する
    /// </summary>
    List<CounterInfo> GetCounters(string sessionId);
    
    /// <summary>
    /// 期間を指定してカウンターデータを取得する
    /// </summary>
    List<CounterInfo> GetCounters(string sessionId, DateTime startTime, DateTime endTime);
    
    /// <summary>
    /// セッションが存在するかチェックする
    /// </summary>
    bool SessionExists(string sessionId);
    
    /// <summary>
    /// 古いセッションを削除する（任意）
    /// </summary>
    void CleanupExpiredSessions(TimeSpan expirationTime);
}
```

### 3. InMemoryDataService 実装

`Services/InMemoryDataService.cs`:

```csharp
public class InMemoryDataService : IDataService
{
    private readonly ConcurrentDictionary<string, SessionInfo> _sessions = new();
    
    public string CreateSession(List<CounterInfo> counters)
    {
        var sessionId = Guid.NewGuid().ToString("N");
        var session = new SessionInfo
        {
            SessionId = sessionId,
            CreatedAt = DateTime.UtcNow,
            LastAccessedAt = DateTime.UtcNow,
            Counters = counters
        };
        
        _sessions[sessionId] = session;
        return sessionId;
    }
    
    public List<CounterInfo> GetCounters(string sessionId)
    {
        if (!_sessions.TryGetValue(sessionId, out var session))
        {
            throw new KeyNotFoundException($"Session {sessionId} not found");
        }
        
        session.LastAccessedAt = DateTime.UtcNow;
        return session.Counters;
    }
    
    public List<CounterInfo> GetCounters(string sessionId, DateTime startTime, DateTime endTime)
    {
        var counters = GetCounters(sessionId);
        
        return counters.Select(c => new CounterInfo
        {
            Name = c.Name,
            ProcessName = c.ProcessName,
            CounterType = c.CounterType,
            DisplayName = c.DisplayName,
            Data = c.Data.Where(d => d.Timestamp >= startTime && d.Timestamp <= endTime).ToList()
        }).ToList();
    }
    
    public bool SessionExists(string sessionId)
    {
        return _sessions.ContainsKey(sessionId);
    }
    
    public void CleanupExpiredSessions(TimeSpan expirationTime)
    {
        var now = DateTime.UtcNow;
        var expiredSessions = _sessions
            .Where(kvp => now - kvp.Value.LastAccessedAt > expirationTime)
            .Select(kvp => kvp.Key)
            .ToList();
        
        foreach (var sessionId in expiredSessions)
        {
            _sessions.TryRemove(sessionId, out _);
        }
    }
}
```

### 4. FileController の更新

既存の `FileController.cs` を更新し、CSVアップロード後にセッションを作成してセッションIDを返すようにする。

```csharp
[ApiController]
[Route("api/file")]
public class FileController : ControllerBase
{
    private readonly ICsvImporter _csvImporter;
    private readonly IDataService _dataService;
    
    public FileController(ICsvImporter csvImporter, IDataService dataService)
    {
        _csvImporter = csvImporter;
        _dataService = dataService;
    }
    
    [HttpPost("upload")]
    public async Task<ActionResult<UploadResponse>> UploadFile(IFormFile file)
    {
        if (file == null || file.Length == 0)
        {
            return BadRequest("No file provided");
        }
        
        using var stream = file.OpenReadStream();
        var counters = _csvImporter.Import(stream);
        
        var sessionId = _dataService.CreateSession(counters);
        
        return Ok(new UploadResponse
        {
            SessionId = sessionId,
            CounterCount = counters.Count,
            DataPoints = counters.Sum(c => c.Data.Count)
        });
    }
}

public class UploadResponse
{
    public string SessionId { get; set; }
    public int CounterCount { get; set; }
    public int DataPoints { get; set; }
}
```

### 5. AnalysisController の修正

スタブ状態の `AnalysisController` を、実際に `IDataService` を使ってデータを取得するように修正する。

```csharp
[HttpPost("slope")]
public ActionResult<SlopeResponse> CalculateSlope([FromBody] SlopeRequest request)
{
    if (string.IsNullOrWhiteSpace(request.SessionId))
    {
        return BadRequest("SessionId is required");
    }
    
    if (!_dataService.SessionExists(request.SessionId))
    {
        return NotFound($"Session {request.SessionId} not found");
    }
    
    var counters = _dataService.GetCounters(
        request.SessionId,
        request.StartTime,
        request.EndTime
    );
    
    var results = _slopeAnalyzer.Calculate(
        counters,
        request.StartTime,
        request.EndTime,
        request.ThresholdKBPer10Min
    );
    
    return Ok(new SlopeResponse { Results = results });
}
```

### 6. DataController の作成（任意）

データ取得専用のエンドポイントを追加する場合。

```csharp
[ApiController]
[Route("api/data")]
public class DataController : ControllerBase
{
    private readonly IDataService _dataService;
    
    public DataController(IDataService dataService)
    {
        _dataService = dataService;
    }
    
    [HttpGet("{sessionId}")]
    public ActionResult<DataResponse> GetData(
        string sessionId,
        [FromQuery] DateTime? startTime,
        [FromQuery] DateTime? endTime)
    {
        if (!_dataService.SessionExists(sessionId))
        {
            return NotFound($"Session {sessionId} not found");
        }
        
        var counters = startTime.HasValue && endTime.HasValue
            ? _dataService.GetCounters(sessionId, startTime.Value, endTime.Value)
            : _dataService.GetCounters(sessionId);
        
        return Ok(new DataResponse { Counters = counters });
    }
}

public class DataResponse
{
    public List<CounterInfo> Counters { get; set; }
}
```

### 7. DI 登録

`Program.cs` に `IDataService` を登録する。

```csharp
builder.Services.AddSingleton<IDataService, InMemoryDataService>();
```

### 8. ユニットテスト作成

`InMemoryDataServiceTests.cs`:

```csharp
public class InMemoryDataServiceTests
{
    [Fact]
    public void CreateSession_ReturnsUniqueSessionId()
    {
        var service = new InMemoryDataService();
        var counters = new List<CounterInfo>();
        
        var sessionId1 = service.CreateSession(counters);
        var sessionId2 = service.CreateSession(counters);
        
        Assert.NotEqual(sessionId1, sessionId2);
    }
    
    [Fact]
    public void GetCounters_ReturnsStoredData()
    {
        var service = new InMemoryDataService();
        var counters = new List<CounterInfo>
        {
            new() { Name = "Test Counter", Data = new List<DataPoint>() }
        };
        
        var sessionId = service.CreateSession(counters);
        var retrieved = service.GetCounters(sessionId);
        
        Assert.Single(retrieved);
        Assert.Equal("Test Counter", retrieved[0].Name);
    }
    
    [Fact]
    public void GetCounters_WithTimeRange_FiltersData()
    {
        // テスト実装...
    }
    
    [Fact]
    public void GetCounters_InvalidSessionId_ThrowsException()
    {
        var service = new InMemoryDataService();
        
        Assert.Throws<KeyNotFoundException>(() => 
            service.GetCounters("invalid-session-id"));
    }
    
    [Fact]
    public void CleanupExpiredSessions_RemovesOldSessions()
    {
        // テスト実装...
    }
}
```

## 受け入れ基準

- [ ] CSVアップロード後にセッションIDが発行される
- [ ] セッションIDでカウンターデータを取得できる
- [ ] 時間範囲を指定してデータをフィルタできる
- [ ] 存在しないセッションIDで404エラーが返る
- [ ] `AnalysisController` が実際に傾き算出を実行する
- [ ] 複数のセッションを同時に管理できる
- [ ] ユニットテストが全て通る

## 技術メモ

### セッション管理の方式

本実装では **インメモリセッション管理** を採用しています。

| 方式 | メリット | デメリット |
|------|----------|------------|
| **インメモリ** | 高速、実装が簡単 | サーバー再起動でデータ消失、スケールアウト不可 |
| Redis | 永続化、スケールアウト可能 | インフラが必要、遅延が増加 |
| データベース | 永続化、検索可能 | I/O コスト大、オーバースペック |

本アプリは **一時的な分析ツール** であり、永続化は不要なため、インメモリ方式が適切です。

### ConcurrentDictionary の選択理由

`ConcurrentDictionary<TKey, TValue>` はスレッドセーフな辞書実装で、複数のHTTPリクエストが同時にセッションにアクセスしても安全です。

### セッションIDの生成

`Guid.NewGuid().ToString("N")` で32文字の16進数文字列（ハイフンなし）を生成します。

例: `a1b2c3d4e5f6789012345678901234ab`

衝突の確率は天文学的に低いため、重複チェックは不要です。

### 有効期限管理（オプション）

本タスクでは必須ではありませんが、メモリリークを防ぐために定期的に古いセッションを削除するバックグラウンドタスクを実装することも検討できます。

```csharp
// Program.cs でバックグラウンドサービスを登録
builder.Services.AddHostedService<SessionCleanupService>();
```

---

## 完了日

（完了時に記入）
